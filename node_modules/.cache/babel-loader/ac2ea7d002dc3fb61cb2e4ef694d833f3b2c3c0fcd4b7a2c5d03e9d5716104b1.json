{"ast":null,"code":"import { now, nextTick } from '../../../utils/utils';\nexport default function onTouchEnd(event) {\n  var swiper = this;\n  var data = swiper.touchEventsData;\n  var params = swiper.params,\n    touches = swiper.touches,\n    rtl = swiper.rtlTranslate,\n    $wrapperEl = swiper.$wrapperEl,\n    slidesGrid = swiper.slidesGrid,\n    snapGrid = swiper.snapGrid,\n    enabled = swiper.enabled;\n  if (!enabled) return;\n  var e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  } // Return Grab Cursor\n\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  } // Time diff\n\n  var touchEndTime = now();\n  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap click', e);\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n  data.lastClickTime = now();\n  nextTick(function () {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  var currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n  if (params.cssMode) {\n    return;\n  }\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        var lastMoveEvent = data.velocities.pop();\n        var velocityEvent = data.velocities.pop();\n        var distance = lastMoveEvent.position - velocityEvent.position;\n        var time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n      data.velocities.length = 0;\n      var momentumDuration = 1000 * params.freeModeMomentumRatio;\n      var momentumDistance = swiper.velocity * momentumDuration;\n      var newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      var doBounce = false;\n      var afterBouncePosition;\n      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      var needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        var nextSlide;\n        for (var j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', function () {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeModeSticky) {\n          // If freeModeSticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(function () {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(function () {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(function () {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(function () {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n      }\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      swiper.emit('_freeModeNoMomentumRelease');\n    }\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    return;\n  } // Find current slide\n\n  var stopIndex = 0;\n  var groupSize = swiper.slidesSizesGrid[0];\n  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (typeof slidesGrid[i + _increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + _increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  } // Find current slide size\n\n  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(stopIndex + increment);\n      }\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}","map":{"version":3,"names":["now","nextTick","onTouchEnd","event","swiper","data","touchEventsData","params","touches","rtl","rtlTranslate","$wrapperEl","slidesGrid","snapGrid","enabled","e","originalEvent","allowTouchCallbacks","emit","isTouched","isMoved","grabCursor","setGrabCursor","startMoving","allowSlideNext","allowSlidePrev","touchEndTime","timeDiff","touchStartTime","allowClick","updateClickedSlide","lastClickTime","destroyed","swipeDirection","diff","currentTranslate","startTranslate","currentPos","followFinger","translate","cssMode","freeMode","minTranslate","slideTo","activeIndex","maxTranslate","slides","length","freeModeMomentum","velocities","lastMoveEvent","pop","velocityEvent","distance","position","time","velocity","Math","abs","freeModeMinimumVelocity","freeModeMomentumVelocityRatio","momentumDuration","freeModeMomentumRatio","momentumDistance","newPosition","doBounce","afterBouncePosition","bounceAmount","freeModeMomentumBounceRatio","needsLoopFix","freeModeMomentumBounce","allowMomentumBounce","loop","centeredSlides","freeModeSticky","nextSlide","j","once","loopFix","moveDistance","currentSlideSize","slidesSizesGrid","speed","slideToClosest","updateProgress","setTransition","setTranslate","transitionStart","animating","transitionEnd","setTimeout","updateActiveIndex","updateSlidesClasses","longSwipesMs","stopIndex","groupSize","i","slidesPerGroupSkip","slidesPerGroup","_increment","ratio","increment","longSwipes","longSwipesRatio","shortSwipes","isNavButtonTarget","navigation","target","nextEl","prevEl"],"sources":["F:/FRONTEND/food-app/node_modules/swiper/esm/components/core/events/onTouchEnd.js"],"sourcesContent":["import { now, nextTick } from '../../../utils/utils';\nexport default function onTouchEnd(event) {\n  var swiper = this;\n  var data = swiper.touchEventsData;\n  var params = swiper.params,\n      touches = swiper.touches,\n      rtl = swiper.rtlTranslate,\n      $wrapperEl = swiper.$wrapperEl,\n      slidesGrid = swiper.slidesGrid,\n      snapGrid = swiper.snapGrid,\n      enabled = swiper.enabled;\n  if (!enabled) return;\n  var e = event;\n  if (e.originalEvent) e = e.originalEvent;\n\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n\n  data.allowTouchCallbacks = false;\n\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  } // Return Grab Cursor\n\n\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  } // Time diff\n\n\n  var touchEndTime = now();\n  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap click', e);\n\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = now();\n  nextTick(function () {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  var currentPos;\n\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        var lastMoveEvent = data.velocities.pop();\n        var velocityEvent = data.velocities.pop();\n        var distance = lastMoveEvent.position - velocityEvent.position;\n        var time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n      data.velocities.length = 0;\n      var momentumDuration = 1000 * params.freeModeMomentumRatio;\n      var momentumDistance = swiper.velocity * momentumDuration;\n      var newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      var doBounce = false;\n      var afterBouncePosition;\n      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      var needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        var nextSlide;\n\n        for (var j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', function () {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeModeSticky) {\n          // If freeModeSticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(function () {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(function () {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(function () {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(function () {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      swiper.emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    return;\n  } // Find current slide\n\n\n  var stopIndex = 0;\n  var groupSize = swiper.slidesSizesGrid[0];\n\n  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n    if (typeof slidesGrid[i + _increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + _increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  } // Find current slide size\n\n\n  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(stopIndex + increment);\n      }\n\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}